# Why Copy-and-Swap Fails for Message/Folder

**Goal:** `m2 = m1` → `m2` must end up in exactly the same folders as `m1`.

### Copy-and-Swap version (WRONG)

```cpp
Message& operator=(Message rhs) 
{ 
    swap(*this, rhs); 
    return *this; 
}
```

### Step-by-step

1. `rhs` is copy-constructed from `m1`. Thus, `rhs` is correctly added to all folders. The copy-constructor calls `add_to_folders`.
2. `swap(*this, rhs)` runs → `*this` now has the right folders set.
3. `rhs` (now holding old `*this` data) is destroyed → calls `remove_from_folders()` on the old (usually empty) folder set.
4. Folders still contain pointer to the dead temporary `rhs` → dangling.
5. Living object `m2` is not in the folders → invariant broken.

>Copy-and-swap cannot be used with bidirectional raw pointer relationships.