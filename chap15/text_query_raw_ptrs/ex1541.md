# Raw Pointers vs `shared_ptr` in `Query`

Switching from `std::shared_ptr<Base_Query>` to raw pointers with deep copies changes the semantics:

---

## Example

```cpp
// Raw pointer + deep copy
Query q1(new Word_Query("hello")); // q1 owns a Word_Query
Query q2 = q1;                      // deep copy via clone(), q2 owns a separate Word_Query
```

```cpp
// shared_ptr
Query q1(std::make_shared<Word_Query>("hello"));
Query q2 = q1;  // q1 and q2 share the same object
```

---

## Comparison

| Aspect                  | Raw pointer + deep copy        | shared_ptr                        |
|-------------------------|--------------------------------|-----------------------------------|
| Copying                 | Expensive, allocates new object| Cheap, copies pointer + ref count |
| Lifetime management     | Manual (delete in destructor)  | Automatic via ref count           |
| Shared ownership        | None                           | Yes, multiple owners share object |
| Polymorphism support    | Works via `clone()`            | Works automatically               |

---

## Pros & Cons

| Approach                  | Pros                                                   | Cons                                      |
|---------------------------|--------------------------------------------------------|-------------------------------------------|
| Raw pointer + deep copy    | - Independent objects<br>- Full control over lifetime | - Expensive copies<br>- Manual memory management<br>- No shared access |
| shared_ptr                 | - Automatic lifetime management<br>- Cheap copies<br>- Shared ownership | - Slight overhead of reference counting<br>- Less control over destruction timing |

---

### Summary

- **Deep copy with raw pointers** → every `Query` owns its own copy; no sharing.  
- **shared_ptr** → multiple `Query` instances can share the same underlying object, with automatic lifetime management.  
- Moving to raw pointers **loses shared access** and increases copy overhead,